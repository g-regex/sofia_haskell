\documentclass[notitlepage]{report}
\listfiles
\usepackage{mystyle}
\usepackage{titling}
\usepackage{standalone}
\usepackage[scaled=0.95]{DejaVuSans}
\renewcommand*\familydefault{\sfdefault}

%\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage[scaled=0.85]{DejaVuSansMono}
\usepackage[scaled=0.95]{DejaVuSansMono}

\usepackage[fencedCode,inlineFootnotes,citations,definitionLists,
            hashEnumerators,smartEllipses,pipeTables,tableCaptions,
            hybrid]{markdown}

%\usepackage{showframe}
\usepackage{etoolbox}
\makeatletter
\patchcmd{\@makechapterhead}{\vspace*{50\p@}}{}{}{}
\patchcmd{\@makeschapterhead}{\vspace*{50\p@}}{}{}{}

\newcommand\m[1]{\mintinline{haskell}{#1}}
\newcommand\mh[1]{\mintinline{html}{#1}}
\newcommand\ms[1]{\mintinline{sql}{#1}}

\usepackage{pmboxdraw}

\DeclareUnicodeCharacter{255A}{\pmboxdrawuni{255A}}
\DeclareUnicodeCharacter{2554}{\pmboxdrawuni{2554}}
\DeclareUnicodeCharacter{2551}{\pmboxdrawuni{2551}}

\pretitle{\begin{center}\Huge\bfseries}
\posttitle{\par\end{center}}
\preauthor{\begin{center}\Large\ttfamily}
\postauthor{\end{center}}
\predate{\par\large\centering}
\postdate{\par}

\title{Sofia/Haskell}
\author{Gregor Feierabend}
\date{\today}

\begin{document}
%\begin{titlepage}
%\begin{haddocktitle}
%Sofia/Haskell documentation
%\end{haddocktitle}
%\end{titlepage}

\maketitle

\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup

\chapter{Introduction}
The purpose of this report is to document the work on the Haskell
implementation of the Sofia proof assistant, which is based on the earlier
Python implementation.\footnote{See: %
\url{https://github.com/ZurabJanelidze/sofia}}
The document is work in progress and targets contributors to the project. Hence
no further introduction to the context of the project is given. Note that the
given implementation makes use of the \m{Parser} data type, created by
\textcite{Hutton}, which is available on the web.

\markdownInput{../README.md}
\pagebreak

\section{Grammar}
We agreed on the following EBNF\footnote{Extended Backus-Naur Form} of the
grammar of the Sofia language.
\begin{figure}[h!]
    {\renewcommand{\arraystretch}{2.0}
    \input{figures/ebnf}}
    \caption{EBNF of the Sofia language}\label{fig:EBNFsofia}
\end{figure}

Detailed information about the representation of formal languages by means of an
EBNF can be found online\footnote{%
See: \url{https://en.wikipedia.org/wiki/EBNF}}. For convenience,
the meaning and/or terminology of the symbols used above is given below.
\begin{multicols}{2}
\begin{itemize}
    \item $\langle\texttt{name}\rangle$ is called a non-terminal or a production
    \item $(\cdots)$ groups elements
    \item $|$ means `or'
    \item $\{\cdots\}$ means zero or more repetitions
    \item $[\cdots]$ means zero or one occurrences.
\end{itemize}
\end{multicols}

We will not discuss the various parsers used in this project in detail, but only
mention the EBNFs of the relevant grammars and refer to the relevant module
which implements the parser. The parser for the grammar described in
Figure~\ref{fig:EBNFsofia} is implemented in the \m{SofiaParser} module.

\chapter{Significant Data Structures}
\input{haddock/SofiaTree}

\chapter{Function Reference Sofia}
\input{haddock/Sofia}

\chapter{User Interface}
The web interface through which the user interacts with Sofia provides an input
field imitating a terminal command line. For the sake of uniformity the proof
building command to be entered in this interface resemble the Haskell functions
of the \m{Sofia} module - except for some small adjustments and the fact that no
partial proof has to be given as the last argument.
\\\\
The EBNF for these commands looks as follows:
\begin{figure}[h!]
    {\renewcommand{\arraystretch}{2.0}
    \input{figures/command_ebnf}}
    \caption{EBNF for the commands of the Sofia
             user interface}\label{fig:EBNFcmds}
\end{figure}

When constructing a proof, the command and the history of all commands used to
build up the currently visible proof are sent via \texttt{POST} to the backend.
The backend then checks whether all supplied arguments are valid and calculates
the proof that results from executing all the Haskell functions corresponding to
the commands in the history and the current command in sequence.
\\
There are also some `meta commands', which do not operate on the current proof
but are rather concerned with the appearance of the user interface, storing the
current proof as a postulate or loading a proof from the database. Parsing of
all commands is accomplished by the \m{SofiaCommandParser} module.

\section{Database}
To store axioms, axiom builders, propositions and proofs (for the purposes of
the database they are all the same), we use a table in an SQLite database. This
table has the following form:

\begin{minted}{sql}
CREATE TABLE "axiom_builder"(
    "id"        INTEGER PRIMARY KEY,
    "rubric"    VARCHAR NOT NULL,
    "name"      VARCHAR NOT NULL,
    "schema"    VARCHAR NOT NULL,
    "params"    INTEGER NOT NULL,
    "desc"      VARCHAR NOT NULL,
    "hist"      VARCHAR NOT NULL,
    CONSTRAINT "axiom" UNIQUE ("rubric","name"))
\end{minted}

Each entry as an auto-incrementing (default setting) \ms{"id"} as the primary
key. Further, each entry can be identified by a \emph{unique} combination of a
\ms{"rubric"} and a \ms{"name"} (e.g.\ \texttt{Arithmetic} and
\texttt{Induction}). The column \ms{"schema"} contains string representations of
\m{AxiomSchema}s (see Section~\ref{sec:axiom_schemas}). The column \ms{"params"}
contains the number of parameters required by the \m{AxiomSchema} - this value
is determined by the \m{AxiomSchema}, but is stored for convenience in the table
as well. The \ms{"desc"} column contains some string containing a human readable
description of the axiom builder for the user. Finally, the \ms{"hist"} column
may contain a history of commands that where used to obtain a postulate (or
example proof, theorem, etc.); in the case of axioms the field contains the
empty string.\\\\
Using the \texttt{Persistent} library\footnote{A helpful introduction to
\texttt{Persistent} can be found here:
\url{https://www.yesodweb.com/book/persistent}}, a Haskell data type is created
which directly corresponds to this table:

\newcommand{\htt}[1]{{\small\bfseries\texttt{#1}}}

\begin{haddockdesc}
\item[\mintinline{haskell}{
data AxiomBuilder
}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\begin{tabulary}{\linewidth}{@{}llJ@{}}
    \htt{=}  &   \htt{AxiomBuilder}         &                 \\
             &   \htt{\{  axiomBuilderRubric } &\htt{:: !String} \\
             &   \htt{,   axiomBuilderName   } &\htt{:: !String} \\
             &   \htt{,   axiomBuilderSchema } &\htt{:: !String} \\
             &   \htt{,   axiomBuilderParams } &\htt{:: !Int   } \\
             &   \htt{,   axiomBuilderDesc   } &\htt{:: !String} \\
             &   \htt{,   axiomBuilderHist   } &\htt{:: !String \}}
 \end{tabulary}}
\end{haddockdesc}

\pagebreak
\section{Axiom schemas}\label{sec:axiom_schemas}
\input{haddock/SofiaAxiomParser}
The EBNF for axiom schemas looks as follows:
\begin{figure}[h!]
    {\renewcommand{\arraystretch}{2.0}
    \input{figures/axiom_ebnf}}
    \caption{EBNF for axiom schemas}\label{fig:EBNFaxiom}
\end{figure}

\input{haddock/WebInterface}

\pagebreak
\begingroup
\setstretch{0.8}
\setlength\bibitemsep{10pt}
\printbibliography\
\endgroup
\end{document}
